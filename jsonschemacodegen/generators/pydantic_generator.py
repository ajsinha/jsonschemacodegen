"""

Copyright Â© 2025-2030, All Rights Reserved
Ashutosh Sinha
Email: ajsinha@gmail.com

LEGAL NOTICE:
This software is proprietary and confidential. Unauthorized copying,
distribution, modification, or use is strictly prohibited without
explicit written permission from the copyright holder.

Patent Pending: Certain implementations may be subject to patent applications.

Pydantic Generator - Generate Pydantic models from JSON Schema.

Features:
- Pydantic v2 compatible models
- Field validators from JSON Schema constraints
- Automatic JSON serialization aliases
- Config class generation
"""

import re
from typing import Any, Dict, List, Optional, Set, Tuple
from datetime import datetime

from ..core.reference_resolver import ReferenceResolver


class PydanticGenerator:
    """
    Generates Pydantic model source code from JSON Schema.
    
    Produces Pydantic v2 compatible models with:
    - Proper field definitions with aliases
    - Validation constraints from JSON Schema
    - Model configuration
    """
    
    # Type mappings for Pydantic
    TYPE_MAP = {
        "string": "str",
        "integer": "int",
        "number": "float",
        "boolean": "bool",
        "null": "None",
        "array": "List",
        "object": "Dict[str, Any]",
    }
    
    FORMAT_MAP = {
        "date": "date",
        "date-time": "datetime",
        "time": "time",
        "email": "EmailStr",
        "uri": "AnyUrl",
        "url": "AnyUrl",
        "uuid": "UUID",
        "ipv4": "IPv4Address",
        "ipv6": "IPv6Address",
    }
    
    def __init__(
        self,
        schema: Dict[str, Any],
        resolver: Optional[ReferenceResolver] = None,
        root_class_name: str = "Root",
        use_field_aliases: bool = True,
    ):
        """
        Initialize the Pydantic generator.
        
        Args:
            schema: The JSON Schema
            resolver: Reference resolver
            root_class_name: Name for the root model
            use_field_aliases: Whether to use Field aliases for property names
        """
        self.schema = schema
        self.resolver = resolver or ReferenceResolver(schema)
        self.root_class_name = root_class_name
        self.use_field_aliases = use_field_aliases
        
        # Get resolved schema
        self.resolved_schema = self.resolver.resolve_all()
        
        # Extract definitions
        self.definitions = self.resolved_schema.get(
            "definitions",
            self.resolved_schema.get("$defs", {})
        )
        
        # Track generated models
        self._generated_models: Set[str] = set()
        
        # Track required imports
        self._imports: Set[str] = set()
    
    def generate(self) -> str:
        """
        Generate Pydantic model source code.
        
        Returns:
            Complete Python module as a string
        """
        lines = []
        
        # Generate models
        model_codes = []
        
        # Generate definition models first
        for def_name, def_schema in self.definitions.items():
            if def_schema.get("type") == "object" or "properties" in def_schema:
                model_code = self._generate_model(def_name, def_schema)
                model_codes.append(model_code)
        
        # Generate root model
        if self.resolved_schema.get("type") == "object" or "properties" in self.resolved_schema:
            model_code = self._generate_model(self.root_class_name, self.resolved_schema)
            model_codes.append(model_code)
        
        # Build complete module
        lines.append(self._generate_header())
        lines.append("")
        lines.append(self._generate_imports())
        lines.append("")
        lines.append("")
        
        # Add models
        for model_code in model_codes:
            if model_code:
                lines.append(model_code)
                lines.append("")
        
        return "\n".join(lines)
    
    def _generate_header(self) -> str:
        """Generate module docstring."""
        return f'''"""
Auto-generated Pydantic models from JSON Schema.

Generated by JsonSchemaCodeGen on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

This module contains Pydantic v2 models generated from JSON Schema definitions.
"""'''
    
    def _generate_imports(self) -> str:
        """Generate import statements."""
        imports = [
            "from __future__ import annotations",
            "",
            "from typing import Any, Dict, List, Optional, Union",
            "from datetime import datetime, date, time",
            "from uuid import UUID",
            "",
            "from pydantic import BaseModel, Field, ConfigDict, field_validator",
        ]
        
        # Add type-specific imports
        if "EmailStr" in str(self._imports):
            imports.append("from pydantic import EmailStr")
        if "AnyUrl" in str(self._imports):
            imports.append("from pydantic import AnyUrl")
        if "IPv4Address" in str(self._imports) or "IPv6Address" in str(self._imports):
            imports.append("from ipaddress import IPv4Address, IPv6Address")
        
        return "\n".join(imports)
    
    def _generate_model(
        self,
        model_name: str,
        schema: Dict[str, Any],
    ) -> str:
        """Generate code for a single Pydantic model."""
        if model_name in self._generated_models:
            return ""
        
        self._generated_models.add(model_name)
        
        lines = []
        
        # Class definition
        lines.append(f"class {model_name}(BaseModel):")
        
        # Docstring
        description = schema.get("description", f"Generated model for {model_name}.")
        lines.append(f'    """{description}"""')
        lines.append("")
        
        # Model config
        lines.append("    model_config = ConfigDict(")
        lines.append("        populate_by_name=True,")
        lines.append("        str_strip_whitespace=True,")
        lines.append("    )")
        lines.append("")
        
        # Get properties
        properties = schema.get("properties", {})
        required = set(schema.get("required", []))
        
        if not properties:
            lines.append("    pass")
            return "\n".join(lines)
        
        # Generate fields
        for prop_name, prop_schema in properties.items():
            field_code = self._generate_field(
                prop_name,
                prop_schema,
                prop_name in required,
            )
            lines.append(field_code)
        
        # Generate validators if there are patterns or custom validation
        validators = self._generate_validators(properties, schema)
        if validators:
            lines.append("")
            lines.extend(validators)
        
        return "\n".join(lines)
    
    def _generate_field(
        self,
        prop_name: str,
        schema: Dict[str, Any],
        is_required: bool,
    ) -> str:
        """Generate a Pydantic field definition."""
        safe_name = self._to_safe_name(prop_name)
        type_hint = self._get_type_hint(schema)
        
        # Build Field arguments
        field_args = []
        
        # Alias for original property name
        if self.use_field_aliases and safe_name != prop_name:
            field_args.append(f'alias="{prop_name}"')
        
        # Description
        if "description" in schema:
            desc = schema["description"].replace('"', '\\"')
            field_args.append(f'description="{desc}"')
        
        # Default value
        if not is_required:
            if "default" in schema:
                default = self._format_default(schema["default"])
                field_args.append(f"default={default}")
            else:
                field_args.append("default=None")
        
        # Constraints
        constraints = self._get_constraints(schema)
        field_args.extend(constraints)
        
        # Build the field line
        if not is_required:
            type_hint = f"Optional[{type_hint}]"
        
        if field_args:
            field_str = f"Field({', '.join(field_args)})"
            return f"    {safe_name}: {type_hint} = {field_str}"
        elif not is_required:
            return f"    {safe_name}: {type_hint} = None"
        else:
            return f"    {safe_name}: {type_hint}"
    
    def _get_type_hint(self, schema: Dict[str, Any]) -> str:
        """Get Pydantic type hint from schema."""
        # Handle $ref
        if "$ref" in schema:
            ref = schema["$ref"]
            class_name = ref.split("/")[-1]
            return f'"{class_name}"'
        
        # Handle enum
        if "enum" in schema:
            return "str"  # Could generate Literal type
        
        # Handle const
        if "const" in schema:
            val = schema["const"]
            return f"Literal[{repr(val)}]"
        
        # Get type
        schema_type = schema.get("type")
        
        # Handle multiple types
        if isinstance(schema_type, list):
            types = [self.TYPE_MAP.get(t, "Any") for t in schema_type if t != "null"]
            if "null" in schema_type:
                return f"Optional[Union[{', '.join(types)}]]"
            return f"Union[{', '.join(types)}]"
        
        # Handle format
        format_type = schema.get("format")
        if format_type and format_type in self.FORMAT_MAP:
            self._imports.add(self.FORMAT_MAP[format_type])
            return self.FORMAT_MAP[format_type]
        
        # Handle array
        if schema_type == "array":
            items = schema.get("items", {})
            item_type = self._get_type_hint(items)
            return f"List[{item_type}]"
        
        # Handle object
        if schema_type == "object":
            if "properties" in schema:
                # This should reference another model
                title = schema.get("title")
                if title:
                    return f'"{self._to_class_name(title)}"'
                return "Dict[str, Any]"
            
            additional = schema.get("additionalProperties")
            if isinstance(additional, dict):
                value_type = self._get_type_hint(additional)
                return f"Dict[str, {value_type}]"
            return "Dict[str, Any]"
        
        return self.TYPE_MAP.get(schema_type, "Any")
    
    def _get_constraints(self, schema: Dict[str, Any]) -> List[str]:
        """Get Pydantic Field constraints from schema."""
        constraints = []
        
        # String constraints
        if "minLength" in schema:
            constraints.append(f"min_length={schema['minLength']}")
        if "maxLength" in schema:
            constraints.append(f"max_length={schema['maxLength']}")
        if "pattern" in schema:
            pattern = schema["pattern"].replace("\\", "\\\\")
            constraints.append(f'pattern=r"{pattern}"')
        
        # Numeric constraints
        if "minimum" in schema:
            constraints.append(f"ge={schema['minimum']}")
        if "maximum" in schema:
            constraints.append(f"le={schema['maximum']}")
        if "exclusiveMinimum" in schema:
            constraints.append(f"gt={schema['exclusiveMinimum']}")
        if "exclusiveMaximum" in schema:
            constraints.append(f"lt={schema['exclusiveMaximum']}")
        if "multipleOf" in schema:
            constraints.append(f"multiple_of={schema['multipleOf']}")
        
        # Array constraints
        if "minItems" in schema:
            constraints.append(f"min_length={schema['minItems']}")
        if "maxItems" in schema:
            constraints.append(f"max_length={schema['maxItems']}")
        
        return constraints
    
    def _generate_validators(
        self,
        properties: Dict[str, Any],
        schema: Dict[str, Any],
    ) -> List[str]:
        """Generate field validators."""
        validators = []
        
        for prop_name, prop_schema in properties.items():
            safe_name = self._to_safe_name(prop_name)
            
            # Add validator for enum values
            if "enum" in prop_schema:
                enum_values = prop_schema["enum"]
                validators.extend([
                    f"    @field_validator('{safe_name}')",
                    f"    @classmethod",
                    f"    def validate_{safe_name}(cls, v):",
                    f"        if v is not None and v not in {enum_values}:",
                    f"            raise ValueError(f'{{v}} is not a valid value for {prop_name}')",
                    f"        return v",
                    "",
                ])
        
        return validators
    
    def _format_default(self, value: Any) -> str:
        """Format a default value for code generation."""
        if isinstance(value, str):
            return f'"{value}"'
        elif isinstance(value, bool):
            return str(value)
        elif value is None:
            return "None"
        elif isinstance(value, (list, dict)):
            return repr(value)
        return str(value)
    
    def _to_safe_name(self, name: str) -> str:
        """Convert to valid Python identifier."""
        safe = name.replace("-", "_").replace(" ", "_").replace(".", "_")
        if safe and safe[0].isdigit():
            safe = "_" + safe
        
        keywords = {"class", "def", "return", "import", "from", "for", "while",
                   "if", "else", "elif", "try", "except", "finally", "with",
                   "as", "is", "in", "not", "and", "or", "True", "False", "None"}
        if safe in keywords:
            safe = safe + "_"
        
        return safe
    
    def _to_class_name(self, name: str) -> str:
        """Convert to valid class name."""
        words = re.split(r"[-_\s]+", name)
        return "".join(word.capitalize() for word in words if word)


def generate_pydantic_models(
    schema: Dict[str, Any],
    root_class_name: str = "Root",
    **kwargs,
) -> str:
    """
    Convenience function to generate Pydantic models from a schema.
    
    Args:
        schema: The JSON Schema
        root_class_name: Name for the root model
        **kwargs: Additional arguments for PydanticGenerator
        
    Returns:
        Python source code as string
    """
    generator = PydanticGenerator(
        schema,
        root_class_name=root_class_name,
        **kwargs,
    )
    return generator.generate()
